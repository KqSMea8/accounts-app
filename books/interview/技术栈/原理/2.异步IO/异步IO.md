1. PHP同步阻塞，易于编写，大型网站效率低下

1. 同步/异步时间开销
    
        //同步模式
        getData('from_db');         //时间为M
        
        getData('from_remote_api'); //时间为N
        
        //异步模式
        getData('from_db', function (result) {
         //时间为M
        });
        getData('from_remote_api', function (result) {
         //时间为N
        }); 
        
        //前者为M+N，后者为max（M, N）。
    
1. 不同IO类型对应开销

    - CPU一级缓存 3
    - CPU二级缓存 14
    - 内存    250
    - 硬盘 41000000
    - 网络 240000000 

1. 资源分配
    
    如果多线程开销小于并行执行，多线程是首选的。但是创建线程与执行线程切换代价比较大。还存在锁，状态同步问题。

    添加资源，比如增加三倍服务器，是一种提升服务质量的方式，但不是唯一方式。
    
    Node在两者之间给出方案：利用单线程，远离死锁，状态同步问题。利用异步IO，让单线程远离阻塞，更好的使用CPU。
    
1. 异步IO
    
    NODE应用（JS文件运行进程）-IO调用（异步调用-操作系统-处理请求-返回数据）-其他调用-执行回调

    操作系统内核对于IO只有两种方式：阻塞/非阻塞。再调用阻塞IO时，应用程序需要等待IO完成才有返回结果。
    
    以阻塞IO，调用硬盘文件为例：系统内核读取磁盘寻道-读取数据-复制数据到内存-调用结束。
    
    阻塞IO造成CPU等待IO，浪费等待时间。为提高性能，系统内核提供非阻塞IO，非阻塞IO调用后立即返回。
    
    阻塞IO流程：NODE应用-阻塞调用（等待数据）-系统内核-读取数据（见上）-返回数据-NODE应用继续执行。
    
    非阻塞IO流程：NODE应用-非阻塞调用-系统内核-立即返回-执行回调。
    
1. 问题

    非阻塞IO性能提升是明显的，但是也存在一些问题。由于完整的IO没有完成，返回的并不是业务系统期望数据。为了获得完整数据，应用程序需要重复调用IO操作来确认是否完成，这个过程叫做轮询。
    
    阻塞IO造成CPU等待浪费，非阻塞带来的麻烦是需要轮询确认是否完全获取数据。会让CPU处于状态判断，是对CPU的资源浪费。
    
1. 我们来看看轮询技术是如何演进的

    -     read：最原始，性能最低。通过重复调用检查IO状态完成数据读取。得到最终数据前，cpu一直耗在等待上。
          流程：应用-read非阻塞调用-系统内核-立即返回-循环以上过程
    -     select:对read做改进，通过文件描述符的事件状态进行判断。采用1024数组存储状态，也就是说，最多可以同时检查1024各文件描述符。poll:对select改进，采用链表方式避免数组限制，还可以避免不必要的检查。当文件较多时，性能低下。
          流程与read类似
    -     epoll:linux下效率最高的IO事件通知机制。进入轮询时候没有检查到IO事件，将会进入休眠，直到事件将它唤醒。真正利用事件通知、执行回调方式，而不是遍历查询，所以不会浪费CPU，执行效率高。
          流程：应用-epoll调用（调用后当前进程休眠）-系统内核-返回消息-打破休眠-循环以上过程

1. 理想的异步IO

    尽管epoll已经利用事件降低cpu耗用，但是休眠期间cpu几乎闲置，对当前线程利用率不够。
    
    我们希望：应用程序发起非阻塞调用，无需遍历或者唤醒等方式轮询，可以继续处理下一个任务，只需要等待IO完成后通过信号或者回调将数据传递给应用即可。
    
    流程：应用-非阻塞调用-系统内核-立即返回-应用-其他操作-系统内核-返回数据（事件/信号）-执行回调
    
    幸运的是，linux下存在一种方式,提供了一种异步IO方式：AIO。不幸的是，只有linux下才有。
    
1. 现实中的异步IO
    
    理想比现实骨感一些。利用多线程，通过部分线程IO加轮询技术完成数据获取：让一个线程计算处理，通过线程通信将IO得到的数据进行传递，这样轻松实现了异步IO。

    流程：应用（主线程）-IO调用-IO线程1-主线程-IO调用-IO线程2
    
    IO线程1，IO线程2调用系统内核，返回数据，主线程执行回调。

    AIO就是典型的线程池模拟异步IO，但是一些缺陷很难使用。libev作者重新实现了异步IO库:libeio，也是通过采用线程池和阻塞IO模拟异步非阻塞IO。最初Node通过libeio配合libev实现IO部分，实现了异步IO。在v0.0.3中，自行实现了线程池来完成异步IO。
    
    另一种方式是windows下的IOCP，提供了理想的异步IO。内部实现原理仍然是线程池，不同之处这些线程池由系统内核管理。
    
    IOCP异步IO模型与Node异步调用模型非常相似。
    
    Node提供libuv为中间层，封装linux和windows的差异。
    
    流程：node-libuv-linux(自定义线程池)/windows(IOCP)
    
1. Node不是单线程的

    我们平时常说的node是单线程的，仅仅是在js中执行单线程罢了。无论是调用linux或者windows平台，内部完成IO任务的另有线程池。
    
1. JS 中异步IO
      - 主线程
    
    JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。
        
    JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
        
    所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
    
    为了利用多核CPU的计算能力，HTML5提出Web
    Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
    
    - 事件队列
        
    单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
    如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。
    
    JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
        
    于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"事件队列"（event queue）的任务，只有"事件队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
        
    具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）
     
    ```
    （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
    （2）主线程之外，还存在一个"事件队列"（event queue）。只要异步任务有了运行结果，就在"事件队列"之中放置一个事件。
    （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"事件队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
    （4）主线程不断重复上面的第三步。
    只要主线程空了，就会去读取"事件队列"，这就是JavaScript的运行机制。这个过程会不断重复。
    ```    
    
    - 事件
    
        "事件队列"也可以理解成消息队列或者任务队列，IO设备完成一项任务，就在"事件队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"事件队列"，就是读取里面有哪些事件。
    
        "事件队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"事件队列"，等待主线程读取。
        
        "事件队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"事件队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
        
1. Node 异步IO
 
    Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。

    - 流程
    
        V8引擎解析JS脚本。node应用调用IO API，ICOP/libuv执行IO API，将不同的任务分配给不同线程，形成时间循环。以异步形式返回给V8引擎。
    
    - 事件循环
    
        启动node进程时 时候，node创建一个while(true)事件循环，每次执行循环我们称之为tick。每个tick过程检查时候事件队列是否有事件待处理，如果有，取出事件以及回调函数。如果存在回调函数，执行他们。然后进入下个循环。
    
    - 观察者
    
        每个循环中，如何判断是否有事件需要处理呢？这里需要引入的概念就是观察者。每个事件循环有一个或者多个观察者，判断是否有事件需要处理的过程就是询问这些观察者是否有待处理的事件。
    
        浏览器采用了类似机制，事件来源用户点击或者加载，这些事件都有对应的观察者。在node中，事件来自于网络请求\文件IO等，有对应的网络IO观察者，文件IO观察者。
        
        每当发起异步调用时候，就会在观察者上计数，当异步调用完成时，就会减少计数。比如tcp listen时，就会有tcp watcher计数，表明可以接受tcp请求，close掉就会减少计数。事件队列就不会增加新的事件。
        
        事件循环是典型的生产/消费模型。异步IO，网络请求是事件生产者，源源不断的为node提供事件，这些事件被传递到对应观察者哪里，事件循环从观察者取出事件并进行处理。
        
        windows循环基于iocp创建，linux循环基于多线程创建。
        
    - 请求对象
    
        当我们调用异步IO，js调用内核执行IO操作时候，存在一个中间产物，叫做请求对象,以下流程以读取文件为例。
    
        流程:IO API调用-调用c++内建模块-通过libuv进行系统调用（判断平台）-调用uv_fs_open,创建FSReqWrap请求对象，参数，回调(oncomplete_sym属性)封装在了这个请求对象上。windows通过QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池等待执行。
        
        至此，JS调用立即返回，js异步调用第一个阶段结束，主线程执行后续操作，而IO在线程池中等待操作，不会阻塞主线程执行。
        
    - 执行回调
        
        回调是第二部分，线程池IO操作调用完毕之后，会把结果存储在FSReqWrap请求对象的result属性，然后通知IOCP/libuv，告诉当前对象操作已完成，并归还线程给线程池。
    
        每次tick过程中，都会调用IOCP/libuv相应方法检查线程池中是否有完成的请求。如果有，放入事件队列的IO观察者队列中。
        
        IO观察者执行回调就是取出req对象result属性作为参数，取出oncomplete_sym属性作为方法，执行函数。
        
        流程（第二部分）：线程池-创建线程-执行请求对象IO操作-将结果放入请求对象.result属性-通知IOCP/libuv调用完成-归还线程-事件循环-查看调用IOCP/libuv函数检查线程池中是否有完成的请求对象-如果有放入IO观察者队列-处理事件-取出result和oncomplete_sys属性执行函数。
    
1. 非IO的异步API

    - 定时器
        在setTimeout与setInterval创建时，定时器对象会被定时器观察者插入到内部的红黑树中。每次tick执行，会从红黑树取出定时器对象，检查是否超过定时时间，如果超时，形成一个事件，回调函数会被立即执行。
    
        定时器并非十分精确。尽管事件循环非常快，但是某一次循环占用事件较多，那么下次循环，或者已经超时很久了。比如10ms以后执行，但是9ms后，一个任务占用了cpu 5ms 时间片，再次轮到定时器时，事件已经过期4ms。
        
        setTimeout流程：Node进程-setTimeout-生成定时器对象-放入事件循环定时器观察者中-事件循环-创建事件循环-进入循环-检查定时器观察者是否有定时器对象-检查时间是否到达-如果超时-生成事件放入事件队列-移除事件-事件循环-发现事件队列有事件---返回给v8引擎-执行事件
            
    - nextTick与setImmediate
        
        二者均为下次tick执行时候执行，而nextTick优先级高于setImmediate，因为，前者属于idle观察者，后者属于check观察者，idle观察者优先级高于定时器观察者高于check观察者。nextTick回调函数放在数组中，而setTimmediate回调函数保存于链表中。

1. 网络IO请求与高性能服务器

    - 网络请求
    
        流程：监听端口-接收网络请求-发送给IO观察者形成事件-事件循环-执行IO观察者中事件回调-如果有业务回调-执行回调函数
        
    - 几种经典服务器模型
    
        -  同步：一次只能处理一个请求，阻塞其他请求。
        -  每请求一个进程：可以处理多个请求，但是不具有扩展性，系统资源有限。
        -  每请求一个线程（多线程）：每个线程都会占用一定内存，大量请求时内存容易耗光，导致服务缓慢，对大型站点不满足需求。

    多线程的方式被Apache采用。node与nginx采用了事件驱动，nginx采用纯c编写，性能较高，但是只适合做web服务器，用于反向代理与负载均衡等服务，但是业务处理方面比较欠缺。node则是一套高性能的业务平台，可以处理业务逻辑，并且保持网络畅通。单node由于自身特点，不适合处理计算密集型业务，可靠性低（进程崩掉以后服务器挂掉）等，node服务器用来做中间层再好不过。


